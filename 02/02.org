:PROPERTIES:
:header-args:racket: :tangle (concat (plist-get (plist-get (org-element-at-point) 'src-block) ':name) ".rkt")
:END:
#+TITLE: Chapter 2 SICP


* Exercise 1
#+NAME: 1
#+begin_src racket
  #lang racket
  (require "../SicpLibrary/sicp-library.rkt")

  (define (make-rat x y)
    (if (and (< x 0)
             (< y 0))
        (cons (abs x) (abs y))
        (cons x y)))
#+end_src



* Exercise 2
#+NAME: 2
#+begin_src racket
  #lang racket

  (require "../SicpLibrary/sicp-library.rkt")

  (define (make-point x y)
    (cons x y))

  (define (x-point p)
    (car p))

  (define (y-point p)
    (cdr p))

  (define (make-segment start end)
    (cons start end))

  (define (start-segment seg)
    (car seg))

  (define (end-segment seg)
    (cdr seg))

  (define (seg-y-size seg)
    (abs (- (y-point (start-segment seg))
            (y-point (end-segment seg)))))

  (define (seg-x-size seg)
    (abs (- (x-point (start-segment seg))
            (x-point (end-segment seg)))))

  (define (segment-length seg)
    (sqrt (+ (square (seg-x-size seg))
             (square (seg-y-size seg)))))

  (define (print-point p)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

  ;;; This is not correct...
  ;;; Need to swap x-point and start-segment
  (define (midpoint-segment seg)
    (cons (average (x-point (start-segment seg))
                   (x-point (end-segment seg)))
          (average (y-point (start-segment seg))
                   (y-point (end-segment seg)))))

  (provide (all-defined-out))
#+end_src

* Exercise 3
#+NAME: 3
#+begin_src racket
  #lang racket
  (require "../SicpLibrary/sicp-library.rkt")
  (require "2.rkt")

  ;;; How can I represent a rectangle with cons?
  ;;; I think a rectangle is fully defined by two segments so I'll keep
  ;;; this representation and modify the constructor in order to make it
  ;;; easy to define different abstractions. Where the head is the base and the
  ;;; car is the heigth

  (define (make-rectangle-4p p1 p2 p3 p4)
    ;;; Make a rectangle by using points, the points are defined anti-clock wise
    ;;; from top left to top right
    (cons (make-segment p2 p3)   ;; base
          (make-segment p1 p2))) ;; height

  (define (rect-left-seg rect)
    (car rect))

  (define (rect-base-seg rect)
    (car rect))

  (define (height rect)
    (segment-length (rect-left-seg rect)))

  (define (base rect)
    (segment-length (rect-base-seg rect)))

  (define (rectangle-area rect)
    (* (base rect) (height rect)))

  (define (rectangle-perimeter rect)
    (+ (* (base rect)   2)
       (* (height rect) 2)))

  (define pa (make-point -1.0  1.0))
  (define pb (make-point -1.0 -1.0))
  (define pc (make-point  1.0 -1.0))
  (define pd (make-point  1.0  1.0))

  (define rect (make-rectangle-4p pa pb pc pd))

  (rectangle-area rect)
  (rectangle-perimeter rect)
#+end_src

* Exercise 4
#+NAME: 4
#+begin_src racket
  #lang racket

  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))

  (define (cdr z)
    (z (lambda (p q) q)))
#+end_src

* Exercise 5
#+NAME: 5
#+begin_src racket
  #lang racket

  (define (cons-ab a b)
    (* (expt 2 a)
       (expt 3 b)))


  (define (car-ab num)
    (define (car-impl x)
      (cond [(not (= 0 (remainder x 3))) (/ (log x) (log 2))]
            [else (car-impl (/ x 3))]))
    (car-impl num))

  (define (cdr-ab num)
    (define (cdr-impl x)
      (cond [(not (= 0 (remainder x 2))) (/ (log x) (log 3))]
            [else (cdr-impl (/ x 2))]))
    (cdr-impl num))
#+end_src
