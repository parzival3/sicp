:PROPERTIES:
:header-args:racket: :tangle (concat (plist-get (plist-get (org-element-at-point) 'src-block) ':name) ".rkt")
:END:
#+TITLE: Chapter 1 SICP
* Common Library
  #+NAME: header
#+begin_src racket :tangle sicp-library.rkt
    #lang racket
#+end_src
  #+NAME: square
  #+begin_src racket :tangle sicp-library.rkt
    (define (square n)
      (* n n))

  #+end_src

  #+NAME: slice
  #+begin_src racket :tangle sicp-library.rkt
(define (slice s n)
  (cond ((eq? s null) s)
        ((> n (length s)) null)
        (else (cons (take s n) (slice (drop s 1) n)))))
  #+end_src

  #+NAME: fermat-test
#+begin_src racket :tangle sicp-library.rkt
    (define (expmod base exp m)
      (cond ((= exp 0) 1)
            ((even? exp)
             (remainder (square (expmod base (/ exp 2) m))
                        m))
            (else
             (remainder (* base (expmod base (- exp 1) m)) m))))

    (define (fermat-test n)
      (define (try-it a)
        (= (expmod a n n) a))
      (try-it (+ 1 (random (- n 1)))))


    (define (fast-prime? n times)
      (cond ((= times 0) true)
            ((fermat-test n) (fast-prime? n (- times 1)))
            (else false)))
#+end_src

Probably I should create a more general function
#+NAME: odd-range
#+begin_src racket :tangle sicp-library.rkt
  (define (create-odd-range start end)
    (let ((new-start (if (even? start)
                         (+ 1 start)
                         start)))
      (range new-start (+ end 1) 2)))
#+end_src

#+NAME: cube
#+begin_src racket :tangle sicp-library.rkt
  (define (cube x)
    (* x x x))
#+end_src

  #+NAME: bottom
  #+begin_src racket :tangle sicp-library.rkt
    (provide (all-defined-out))
  #+end_src

* Exercise 5
  Trying to call /f/ with an interpreter that supports only the normal-order of evaluation we will have a infinite loop beacuse /p/
  is a recursive procedure that doesn't have an end condition.
  On the other hand, with an interpreter that uses the applicative order of evaluation, the result will be ~0~ it will try to evaluate
  the /if/ predicate and thus verify that the /a/ paratmeter is in fact ~0~.
  #+begin_src racket
(define (p) (p))

(define (f a b)
  (if (= a 0)
      0
      b))

(f 0 (p))
  #+end_src
* Exercise 6

#+begin_src racket
(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (square x)
  (* x x))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))

(define (new-sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (new-sqrt-iter (improve guess x) x)))

(define (new-sqrt x)
  (new-sqrt-iter 1 x))

;; Better approximation for the cube is given by
;; (x/y^2 + 2y)/3
(define (cube x)
  (* x x x))

(define (sqrt-3 x)
  (define (good-enough? guess)
    (< (abs (- x (cube guess))) 0.001))

  (define (improve guess)
    (/ (+ (/ x (square guess)) (* 2 guess)) 3))

  (define (sqrt-3-iter guess)
    (if (good-enough? guess)
        guess
    (sqrt-3-iter (improve guess))))
  (sqrt-3-iter 1))

(sqrt 2)
(sqrt-3 3)
#+end_src
* Exercise 11
  #+NAME: 11
  #+begin_src racket
    (define (f-iterative n)
      (cond ((< n 3) n)
            (else (+ (f-iterative (- n 1)) (* 2 (f-iterative (- n 2))) (* 3 (f-iterative (- n 3)))))))

    (define (f-recursive n)
      (define (f-impl counter one two three n)
        (cond ((>= counter n) one)
              (else (f-impl (+ 1 counter)
                                 (+ one (* 2 two) (* 3 three))
                                 one
                                 two
                                 n))))
      (f-impl 3 4 3 0 n))
  #+end_src
* Exercise 12
  The exercise is not very clear, but most of the solutions online define a function with two parameters, the row and column number.
  The function /pacal-triangle/ considers a triangle that starts at row 0 and column 0.
  #+NAME: 12
  #+begin_src racket
    (define (pascal-triangle row column)
      (cond ((> column row ) 0)
            ((< row 2) 1)
            ((= column 0) 1)
            (else (+ (pascal-triangle (- row 1) (- column 1))
                     (pascal-triangle (- row 1) column )))))


    (pascal-triangle 2 1)
    (pascal-triangle 3 2)
    (pascal-triangle 4 2)
  #+end_src

* Exercise 13
* Exercise 14
  #+NAME: 14
  #+begin_src racket
    (define (cc amount kinds-of-coins)
      (cond ((= amount 0) 1)
            ((or (< amount 0) (= kinds-of-coins 0)) 0)
            (else (+ (cc amount
                         (- kinds-of-coins 1))
                     (cc (- amount
                            (first-denomination kinds-of-coins))
                         kinds-of-coins)))))
    ;; pretty priting
    (define (cc-pp amount kinds-of-coins)
      (cond ((= amount 0) (list 1 (format "cc ~v ~v \n" 1 kinds-of-coins)))
            ((or (< amount 0) (= kinds-of-coins 0)) (list 0 (format "cc ~v ~v \n" 0 kinds-of-coins)))
            (else

             (let ((a (cc-pp amount (- kinds-of-coins 1)))
                   (b (cc-pp (- amount (first-denomination kinds-of-coins)) kinds-of-coins)))
               (list (+ (car a) (car b)) (string-append (cadr a) " " (cadr b)))))))

    (define-syntax (cc-macro stx)
      (let ((ammount ))
             (kinds-of-coins (caddr (syntax->datum stx))))
         (cond ((= (cadr (syntax->datum stx) 0) 1)
               ((or (< (cadr (syntax->datum stx) 0) (= (caddr (syntax->datum stx) 0)) 0)
               (`(+ (cc-macro ,(cadr (syntax->datum stx) ,(- (caddr (syntax->datum stx) 1))
                (cc-macro ,(- (cadr (syntax->datum stx) (first-denomination
                     (caddr (syntax->datum stx)))
                ,(caddr (syntax->datum stx)))))))

    (define (first-denomination kinds-of-coins)
      (cond ((= kinds-of-coins 1) 1)
            ((= kinds-of-coins 2) 5)
            ((= kinds-of-coins 3) 10)
            ((= kinds-of-coins 4) 25)
            ((= kinds-of-coins 5) 50)))

    (define (count-change amount)
      (cc amount 5))

    (define (count-change-pp amount)
      (cc-pp amount 5))
  #+end_src
* Exercise 15
  #+NAME: 15
  #+begin_src racket
    (define (cube x)
      (* x x x))

    (define (p x)
      (- (* 3 x) (* 4 (cube x))))

    (define (sine angle)
      (print "+ \n")
      (if (not (> (abs angle) 0.1))
          angle
          (p (sine (/ angle 3.0)))))
  #+end_src

* Exercise 16
  #+NAME: 16
#+begin_src racket
    #lang racket
    (require "sicp-library.rkt")

    (define (fast-expr b n)
      (cond ((= n 0) 1)
            ((even? n) (square (fast-expr b (/ n 2))))
            (else (* b (fast-expr b (- n 1))))))

    (define (fast-expr-rec b n)
      (define (fast-expr-impl b n c)
        (cond ((<= n 1) (* b c))
              ((even? n) (fast-expr-impl b (/ n 2) (* c (square b))))
              (else (fast-expr-impl b (- n 1) (* b c)))))
      (fast-expr-impl b n 1))

    (fast-expr 3 3)
    (fast-expr-rec 3 3)

    (provide (all-defined-out))
#+end_src

* Exercise 17
#+NAME: 17
#+begin_src racket
  (define (double x)
    (* 2 x))

  (define (halve x)
    (/ x 2))

  (define (multy a b)
    (if (= b 0)
        0
        (+ a (multy a (- b 1)))))

  (define (fast-multy-rec a b)
    (cond ((= b 1) a)
          ((even? b) (double (fast-multy-rec a (halve b))))
          (else (+ a (fast-multy-rec a (+ b -1))))))


#+end_src

* Exercise 18
#+NAME: 18
#+begin_src racket
<<17>>
  (define (fast-multy-iter a b)
    (define (fast-multy-impl a b acc)
      (cond ((= b 1) acc)
            ((even? b) (fast-multy-impl a (halve b) (+ acc (double a))))
            (else (fast-multy-impl a (+ b -1) (+ acc a)))))
    (fast-multy-impl a b 0))
#+end_src

* Exercise 19
  I've struggled a bit with this exercise, the idea is that you need to find something similar to...
#+NAME: 19
#+begin_src racket
  (define (fib n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a b ? ?))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))

#+end_src

* Exercise 20
  #+NAME: gcd
#+begin_src racket
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (modulo a b))))
#+end_src
#+NAME 20
#+begin_src racket
  <<gcd>>

#+end_src

* Exercise 21
  #+NAME: smallest-divisor
  #+begin_src racket
    #lang racket
    (require "sicp-library.rkt")
    (define (smallest-divisor n)
      (find-divisor n 2))

    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((divides? test-divisor n) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))

    (define (divides? a b)
      (= (remainder b a) 0))

    (define (prime? a)
      (= (smallest-divisor a) a))

    (provide (all-defined-out))
  #+end_src
#+NAME: 21
#+begin_src racket
    #lang racket
    (require threading)
    (require "smallest-divisor.rkt")
    (~> (map (lambda (x) (smallest-divisor x)) (list 199 1999 19999))
        (display _))

#+end_src

* Exercise 22
#+NAME: 22
#+begin_src racket
  #lang racket
  (require threading)
  (require "sicp-library.rkt")
  (require "smallest-divisor.rkt")

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (current-milliseconds)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (current-milliseconds) start-time))
        null))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))


  (define (timed-prime-values n)
    (define (timed-prime-impl n ctime)
      (if (prime? n)
          (cons n (- (current-milliseconds) ctime))
          null))
    (timed-prime-impl n (current-milliseconds)))

  (define (search-for-primes start end)
    (~> (create-odd-range start end)
        (map timed-prime-values _)
        (filter-not null? _)))

  (define (search-for-three-primes-in-ranges l)
    (~> (slice l 2)
        (map (lambda (r) (take (apply search-for-primes r) 3)) _)))
#+end_src

* Exercise 23
#+NAME: 23
#+begin_src racket
  #lang racket
    (require "smallest-divisor.rkt")

  (define (next n)
    (if (= n 2)
        3
        (+ n 2)))

      (define (find-divisor n test-divisor)
        (cond ((> (square test-divisor) n) n)
              ((divides? test-divisor n) test-divisor)
              (else (find-divisor n (next test-divisor)))))
#+end_src

* Exercise 24
#+NAME: 24
#+begin_src racket
  #lang racket
  (require "22.rkt")

  (define (start-prime-test n start-time)
    (if (fast-prime? n)
        (report-prime (- (current-milliseconds) start-time))
        null))
#+end_src

* Exercise 25
#+NAME: 25
#+begin_src racket
  #lang racket

  (require "sicp-library.rkt")
  (require "16.rkt")

  (define (expmod-f base exp m)
    (remainder (fast-expr-rec base exp) m))
#+end_src

* Exercise 26
The procedure is \theta\(n\) instead of \theta\(\log n\) because Lusi calculates the expmod two times for every iteration instead of one.
* Exercise 27
#+NAME: 27
#+begin_src racket
  #lang racket
  (require "sicp-library.rkt")

  (define (charmicheal-test n)
    (andmap (lambda (x) (= (expmod x n n) x)) (range 0 n)))

  (define (solution-27)
    (andmap charmicheal-test '(561 1105 1729 2465 2821 6601)))

  (provide (all-defined-out))
#+end_src

* Exercise 28
#+NAME: 28
#+begin_src racket
  ;;(define  (miller-rabin-test ))
#+end_src

* Exercise 29
#+NAME: 29
#+begin_src racket
  #lang racket

  (require threading)
  (require "sicp-library.rkt")

  (define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

  (define (inc n) (+ n 1))

  (define (sum-cubes a b)
    (sum cube a inc b))

  (define (simpson-rule-book f a b n)
    (define simpson-constant-h (/ (- b a) n))

    (define (simpson-const-next n)
      (cond ((= n 0) 1)
            ((= (remainder n 2) 0) 4)
            ((= (remainder n 3) 0) 2)
            (else 1)))

    (define (simpson-func k)
      (* (simpson-const-next k) (f (+ a (* k simpson-constant-h)))))

    (* (/ simpson-constant-h 3)(sum simpson-func 0 inc n)))


  ;;; Not working as expected, I don't know why...
  (define (simpson-rule f a b n)
    (define simpson-constant-h (/ (- b a) n))

    (define (simpson-const-next n)
      (cond ((= n 1) 4)
            ((= n 4) 2)
            (else 1)))

    (define (simpson-at-point c v)
      (* c (f v)))


    (~> (foldl (lambda (y x) (cons (+ (car x) (simpson-at-point (cdr x) y))
                                   (simpson-const-next (cdr x))))
               (cons 0 0)
               (range a (+ b 1) simpson-constant-h))
        (car _)
        (* (/ simpson-constant-h 3) _)))



  (provide (all-defined-out))
#+end_src

* Exercise 30
#+NAME: 30
#+begin_src racket
  #lang racket

  (define (sum term a next b)
    (define (iter a result)
      (if (> a b)
          result
          (iter (next a) (+ (term a) result))))
    (iter a 0))
#+end_src

* Exercise 31
#+NAME: 31
#+begin_src racket
  #lang racket

  (define (inc x)
    (+ 1 x))

  (define (product term a next b)
    (define (iter a result)
      (if (> a b)
          result
          (iter (next a) (* (term a) result))))
    (iter a 1))

  (define (factorial x)
    (product (lambda (x) x) 1 inc x))

  (define (pi-approx n)

    (define (top-next x)
      (cond ((= (remainder x 2) 0) (+ 2 x))
            (else (+ x 1))))

    (define (bottom-next x)
      (cond ((= (remainder x 2) 0) (+ x 1))
            (else (+ x 2))))

    (define (identity x) x)
    (define top (product top-next 1 inc n ))
    (define bottom (product bottom-next 1 inc n))

    (/ top bottom))
#+end_src
